<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Machine Controller - Machine Controller Manager Design</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../intro.html">Introduction</a></li><li class="chapter-item expanded "><a href="../k8s_facilities.html"><strong aria-hidden="true">1.</strong> Kubernetes Facilities</a></li><li class="chapter-item expanded "><a href="../mcm_facilities.html"><strong aria-hidden="true">2.</strong> MCM Facilities</a></li><li class="chapter-item expanded "><a href="../machine-controller/index.html" class="active"><strong aria-hidden="true">3.</strong> Machine Controller</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../machine-controller/reconcile-cluster-machine-class.html"><strong aria-hidden="true">3.1.</strong> Reconcile Cluster Machine Class</a></li><li class="chapter-item expanded "><a href="../machine-controller/reconcile-cluster-secret.html"><strong aria-hidden="true">3.2.</strong> Reconcile Cluster Secret</a></li><li class="chapter-item expanded "><a href="../machine-controller/cluster_machine_reconcile.html"><strong aria-hidden="true">3.3.</strong> Cluster Machine Reconciliation</a></li><li class="chapter-item expanded "><a href="../machine-controller/mc_helper_methods.html"><strong aria-hidden="true">3.4.</strong> Machine Controller Helper Methods</a></li><li class="chapter-item expanded "><a href="../machine-controller/node_drain.html"><strong aria-hidden="true">3.5.</strong> Node Drain</a></li></ol></li><li class="chapter-item expanded "><a href="../machine-controller-manager/index.html"><strong aria-hidden="true">4.</strong> Machine Controller Manager</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../machine-controller-manager/reconcile-cluster-machine-deployment.html"><strong aria-hidden="true">4.1.</strong> Reconcile Cluster Machine Deployment</a></li></ol></li><li class="chapter-item expanded "><a href="../issues.html"><strong aria-hidden="true">5.</strong> Issues</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Machine Controller Manager Design</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <ul>
<li><a href="#machine-controller">Machine Controller</a>
<ul>
<li><a href="#mc-launch">MC Launch</a>
<ul>
<li><a href="#dev">Dev</a>
<ul>
<li><a href="#build">Build</a></li>
<li><a href="#launch">Launch</a></li>
</ul>
</li>
<li><a href="#prod">Prod</a>
<ul>
<li><a href="#build-1">Build</a></li>
</ul>
</li>
<li><a href="#launch-flow">Launch Flow</a>
<ul>
<li><a href="#summary">Summary</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#machine-controller-loop">Machine Controller Loop</a>
<ul>
<li><a href="#apprun">app.Run</a>
<ul>
<li><a href="#summary-1">Summary</a></li>
</ul>
</li>
<li><a href="#appstartcontrollers">app.StartControllers</a></li>
<li><a href="#machine-controller-initialization">Machine Controller Initialization</a>
<ul>
<li><a href="#1-newcontroller-factory-func">1. NewController factory func</a></li>
<li><a href="#11-init-controller-struct">1.1 Init Controller Struct</a></li>
<li><a href="#12-assign-listers-and-hassynced-funcs-to-controller-struct">1.2 Assign Listers and HasSynced funcs to controller struct</a></li>
<li><a href="#13-register-controller-event-handlers-on-informers">1.3 Register Controller Event Handlers on Informers.</a>
<ul>
<li><a href="#131-secret-informer-callback">1.3.1 Secret Informer Callback</a></li>
<li><a href="#132-machine-class-informer-callbacks">1.3.2 Machine Class Informer Callbacks</a>
<ul>
<li><a href="#machineclass-adddelete-callback-1">MachineClass Add/Delete Callback 1</a></li>
<li><a href="#machineclass-update-callback-1">MachineClass Update Callback 1</a></li>
<li><a href="#machineclass-adddeleteupdate-callback-2">MachineClass Add/Delete/Update Callback 2</a></li>
</ul>
</li>
<li><a href="#132-machine-informer-callbacks">1.3.2 Machine Informer Callbacks</a>
<ul>
<li><a href="#machine-addupdatedelete-callbacks-1">Machine Add/Update/Delete Callbacks 1</a></li>
<li><a href="#machine-updatedelete-callbacks-2">Machine Update/Delete Callbacks 2</a></li>
</ul>
</li>
<li><a href="#133-node-informer-callbacks">1.3.3 Node Informer Callbacks</a>
<ul>
<li><a href="#node-add-callback">Node Add Callback</a></li>
<li><a href="#node-delete-callback">Node Delete Callback</a></li>
<li><a href="#node-update-callback">Node Update Callback</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#machine-controller-run">Machine Controller Run</a>
<ul>
<li><a href="#1-wait-for-informer-caches-to-sync">1. Wait for Informer Caches to Sync</a></li>
<li><a href="#2-register-on-prometheus">2. Register On Prometheus</a>
<ul>
<li><a href="#21-describe-metrics-controllerdescribe">2.1 Describe Metrics (controller.Describe)</a></li>
<li><a href="#21-collect-metrics-controllercollect">2.1 Collect Metrics (controller.Collect)</a>
<ul>
<li><a href="#211-collect-machine-metrics">2.1.1 Collect Machine Metrics</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-create-controller-worker-go-routines-applying-reconciliations">3. create controller worker go-routines applying reconciliations</a>
<ul>
<li><a href="#31-createworker">3.1 createworker</a></li>
</ul>
</li>
<li><a href="#4-reconciliation-functions-executed-by-worker">4. reconciliation functions executed by worker</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="machine-controller"><a class="header" href="#machine-controller">Machine Controller</a></h1>
<p>The <a href="">Machine Controller</a> handles reconciliation of <a href="./../mcm_facilities.html#machine">Machine</a> and <a href="./../mcm_facilities.html#machineclass">MachineClass</a> objects. </p>
<p>The Machine Controller Entry Point for any provider is at 
<code>machine-controller-manager-provider-&lt;name&gt;/cmd/machine-controller/main.go</code></p>
<h2 id="mc-launch"><a class="header" href="#mc-launch">MC Launch</a></h2>
<h3 id="dev"><a class="header" href="#dev">Dev</a></h3>
<h4 id="build"><a class="header" href="#build">Build</a></h4>
<p>A <code>Makefile</code> in the root of <code>machine-controller-manager-provider-&lt;name&gt;</code> builds the provider specific machine controller  for linux with CGO enabled. The <code>make build</code> target invokes the shell script <a href="https://github.com/gardener/machine-controller-manager-provider-aws/blob/master/.ci/build">.ci/build</a> to do this.</p>
<pre><code>CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build \
  -a \
  -v \
  -o ${BINARY_PATH}/rel/machine-controller \
  cmd/machine-controller/main.goo
</code></pre>
<h4 id="launch"><a class="header" href="#launch">Launch</a></h4>
<p>Assuming one has initialized the variables using <code>make download-kubeconfigs</code>, one can then use <code>make start</code> target which launches the MC with flags as shown below.
Most of these timeout flags are redundant since exact same values are 
given in <a href="">machine-controller-manager/pkg/util/provider/app/options.NewMCServer</a></p>
<pre><code>go run -mod=vendor 
    cmd/machine-controller/main.go 
    --control-kubeconfig=$(CONTROL_KUBECONFIG) 
    --target-kubeconfig=$(TARGET_KUBECONFIG) 
    --namespace=$(CONTROL_NAMESPACE) 
    --machine-creation-timeout=20m 
    --machine-drain-timeout=5m 
    --machine-health-timeout=10m 
    --machine-pv-detach-timeout=2m 
    --machine-safety-apiserver-statuscheck-timeout=30s 
    --machine-safety-apiserver-statuscheck-period=1m 
    --machine-safety-orphan-vms-period=30m 
    --leader-elect=$(LEADER_ELECT) 
    --v=3
</code></pre>
<h3 id="prod"><a class="header" href="#prod">Prod</a></h3>
<h4 id="build-1"><a class="header" href="#build-1">Build</a></h4>
<p>A <code>Dockerfile</code> builds the provider specific machine controller and launches it directly with no CLI arguments. Hence uses coded defaults</p>
<pre><code class="language-Dockerfile">RUN CGO_ENABLED=0 GOOS=$TARGETOS GOARCH=$TARGETARCH \
      go build \
      -mod=vendor \
      -o /usr/local/bin/machine-controller \
      cmd/machine-controller/main.go
COPY --from=builder /usr/local/bin/machine-controller /machine-controller
ENTRYPOINT [&quot;/machine-controller&quot;]
</code></pre>
<p>The <code>machine-controller-manager</code> deployment usually launches both the MC in a Pod with following arguments</p>
<pre><code>./machine-controller
         --control-kubeconfig=inClusterConfig
         --machine-creation-timeout=20m
         --machine-drain-timeout=2h
         --machine-health-timeout=10m
         --namespace=shoot--i034796--tre
         --port=10259
         --target-kubeconfig=/var/run/secrets/gardener.cloud/shoot/generic-kubeconfig/kubeconfig
         --v=3
</code></pre>
<h3 id="launch-flow"><a class="header" href="#launch-flow">Launch Flow</a></h3>
<pre class="mermaid">%%{init: {'themeVariables': { 'fontSize': '10px'}, &quot;flowchart&quot;: {&quot;useMaxWidth&quot;: false }}}%%
flowchart TB

Begin((&quot;cmd/
machine-controller/
main.go&quot;))
--&gt;NewMCServer[&quot;mc=options.NewMCServer&quot;]
--&gt;AddFlaogs[&quot;mc.AddFlags(pflag.CommandLine)&quot;]
--&gt;LogOptions[&quot;options := k8s.io/component/base/logs.NewOptions()
	options.AddFlags(pflag.CommandLine)&quot;]
--&gt;InitFlags[&quot;flag.InitFlags&quot;]
InitFlags--local--&gt;NewLocalDriver[&quot;
	driver, err := local.NewDriver(s.ControlKubeconfig)
	if err exit
&quot;]
InitFlags--aws--&gt;NewPlatformDriver[&quot;
	driver := aws.NewAWSDriver(&amp;spi.PluginSPIImpl{}))
	OR
	driver := cp.NewAzureDriver(&amp;spi.PluginSPIImpl{})
	//etc
&quot;]

NewLocalDriver--&gt;AppRun[&quot;
	err := app.Run(mc, driver)
&quot;]
NewPlatformDriver--&gt;AppRun
AppRun--&gt;End((&quot;if err != nil 
os.Exit(1)&quot;))
</pre>
<h4 id="summary"><a class="header" href="#summary">Summary</a></h4>
<ol>
<li>
<p>Creates <a href="https://pkg.go.dev/github.com/gardener/machine-controller-manager@v0.47.0/pkg/util/provider/app/options#MCServer">machine-controller-manager/pkg/util/provider/app/options.MCServer</a> using <code>options.NewMCServer</code> which is the main context object for the machinecontroller that embeds a
<a href="https://pkg.go.dev/github.com/gardener/machine-controller-manager@v0.47.0/pkg/options#MachineControllerManagerConfiguration">options.MachineControllerConfiguration</a>.</p>
<p><code>options.NewMCServer</code> initializes <code>options.MCServer</code> struct with default values for </p>
<ul>
<li><code>Port: 10258</code>, </li>
<li><code>Namespace: default</code>, </li>
<li><code>ConcurrentNodeSyncs: 50</code>: number of worker go-routines that are used to process items from a work queue. See <a href="#31-createworker">Worker</a> below</li>
<li><code>NodeConditions: &quot;KernelDeadLock,ReadonlyFilesystem,DiskPressure,NetworkUnavailable&quot;</code> (failure node conditions that indicate that a machine is un-healthy)</li>
<li><code>MinResyncPeriod: 12 hours</code>, <code>KubeAPIQPS: 20</code>, <code>KubeAPIBurst:30</code>: config params for k8s clients. See <a href="https://pkg.go.dev/k8s.io/client-go@v0.25.3/rest#Config">rest.Config</a></li>
</ul>
</li>
<li>
<p>calls <code>MCServer.AddFlags</code> which defines all parsing flags for the machine controller into fields of <code>MCServer</code> instance created in the last step.</p>
</li>
<li>
<p>calls <code>k8s.io/component-base/logs.NewOptions</code> and then <code>options.AddFlags</code> for logging options. 
TODO: Should get rid of this when moving to <code>logr</code>.) </p>
<ul>
<li>See <a href="https://github.com/gardener/gardener/blob/master/docs/development/logging.md">Logging In Gardener Components</a>. </li>
<li>Then use the <a href="https://github.com/gardener/gardener/tree/master/hack/tools/logcheck">logcheck</a>tool.</li>
</ul>
</li>
<li>
<p>Driver initialization code varies according to the provider type.</p>
<ul>
<li>Local Driver
<ul>
<li>calls <code>NewDriver</code> with control kube config that creates a controller runtime client (<code>sigs.k8s.io/controller-runtime/pkg/client</code>) which then calls <code>pkg/local/driver.NewDriver</code> passing the controlloer-runtime client which constructs a <code>localdriver</code> encapsulating the passed in client.</li>
<li><code>driver := local.NewDriver(c)</code></li>
<li>the <code>localdriver</code> implements <a href="https://github.com/gardener/machine-controller-manager/blob/master/pkg/util/provider/driver/driver.go#l28">Driver</a> is the facade for creation/deletion of vm's</li>
</ul>
</li>
<li>Provider Specific Driver Example
<ul>
<li><code>driver := aws.NewAWSDriver(&amp;spi.PluginSPIImpl{})</code></li>
<li><code>driver := cp.NewAzureDriver(&amp;spi.PluginSPIImpl{})</code></li>
<li><code>spi.PluginSPIImpl</code> is a struct that implements a provider specific interface that initializes a provider session.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>calls <a href="https://github.com/gardener/machine-controller-manager/blob/master/pkg/util/provider/app/app.go#l77">app.Run</a> passing in the previously created <code>MCServer</code> and <code>Driver</code> instances.</p>
</li>
</ol>
<h2 id="machine-controller-loop"><a class="header" href="#machine-controller-loop">Machine Controller Loop</a></h2>
<h3 id="apprun"><a class="header" href="#apprun">app.Run</a></h3>
<p><code>app.Run</code> is the function that setups the main control loop of the machine controller server. </p>
<h4 id="summary-1"><a class="header" href="#summary-1">Summary</a></h4>
<ol>
<li><a href="https://github.com/gardener/machine-controller-manager/blob/v0.48.0/pkg/util/provider/app/app.go#L77">app.Run(options *options.MCServer, driver driver.Driver)</a> is the common run loop for all provider Machine Controllers.</li>
<li>Creates <code>targetkubeconfig</code> and <code>controlkubeconfig</code> of type <code>k8s.io/client-go/rest.Config</code> from the target kube config path using <code>clientcmd.BuildConfigFromFlags</code></li>
<li>Set fields such as <code>config.QPS</code> and <code>config.Burst</code>  in both <code>targetkubeconfig</code> and <code>controlkubeconfig</code> from the passed in <code>options.MCServer</code></li>
<li>Create <code>kubeClientControl</code> from the <code>controlkubeconfig</code> using the standard client-go client factory metohd: <code>kubernetes.NewForConfig</code> that returns a <code>client-go/kubernetes.Clientset</code></li>
<li>Similarly create another <code>Clientset</code> named <code>leaderElectionClient</code> using <code>controlkubeconfig</code></li>
<li>Start a go routine using the function <code>startHTTP</code> that registers a bunch of http handlers for the go profiler, prometheus metrics and the health check.</li>
<li>Call <code>createRecorder</code> passing the <code>kubeClientControl</code> client set instance that returns a <a href="https://github.com/kubernetes/client-go/blob/master/tools/record/event.go#L91">client-go/tools/record.EventRecorder</a>
<ol>
<li>Creates a new <code>eventBroadcaster</code> of type <a href="https://github.com/kubernetes/client-go/blob/master/tools/record/event.go#l113">event.EventBroadcaster</a></li>
<li>Set the logging function of the broadcaster to <code>klog.Infof</code>.</li>
<li>Sets the event sink using <code>eventBroadcaster.StartRecordingToSink</code> passing the event interface as <code>kubeClient.CoreV1().RESTClient()).Events(&quot;&quot;)</code>. Effectively events will be published remotely.</li>
<li>Returns the <code>record.EventRecorder</code> associated with the <code>eventBroadcaster</code> using <code>eventBroadcaster.NewRecorder</code> </li>
</ol>
</li>
<li>Constructs an anonymous function assigned to <code>run</code> variable which does the following:
<ol>
<li>Initializes a <code>stop</code> receive channel.</li>
<li>Creates a <code>controlMachineClientBuilder</code> using <code>machineclientbuilder.SimpleClientBuilder</code> using the <code>controlkubeconfig</code>.</li>
<li>Creates a <code>controlCoreClientBuidler</code> using <code>coreclientbuilder.SimpleControllerClientBuilder</code> wrapping <code>controlkubeconfig</code>.</li>
<li>Creates <code>targetCoreClientBuilder</code> using <code>coreclientbuilder.SimpleControllerClientBuilder</code> wrapping <code>controlkubeconfig</code>.</li>
<li>Call the <code>app.StartControllers</code> function passing the <code>options</code>, <code>driver</code>, <code>controlkubeconfig</code>, <code>targetkubeconfig</code>, <code>controlMachineClientBuilder</code>, <code>controlCoreClientBuilder</code>, <code>targetCoreClientBuilder</code>, <code>recorder</code> and <code>stop</code> channel.
<ul>
<li>// Q: if you are going to pass the controlkubeconfig and targetkubeconfig - why not create the client builders inside the startcontrollers ?</li>
</ul>
</li>
<li>if <code>app.StartcOntrollers</code> return an error panic and exit <code>run</code>.</li>
</ol>
</li>
<li>use <a href="https://github.com/gardener/machine-controller-manager/blob/v0.48.0/pkg/util/provider/app/app.go#L186">leaderelection.RunOrDie</a> to start a leader election and pass the previously created <code>run</code> function to as the callback for <code>OnStartedLeading</code>. <code>OnStartedLeading</code> callback is invoked when a leaderelector client starts leading.</li>
</ol>
<h3 id="appstartcontrollers"><a class="header" href="#appstartcontrollers">app.StartControllers</a></h3>
<p><a href="https://github.com/gardener/machine-controller-manager/blob/v0.48.0/pkg/util/provider/app/app.go#L202">app.StartControllers</a> starts all controller loops which are part of the machine controller. </p>
<pre><code class="language-go">func StartControllers(options *options.MCServer,
	controlCoreKubeconfig *rest.Config,
	targetCoreKubeconfig *rest.Config,
	controlMachineClientBuilder machineclientbuilder.ClientBuilder,
	controlCoreClientBuilder coreclientbuilder.ClientBuilder,
	targetCoreClientBuilder coreclientbuilder.ClientBuilder,
	driver driver.Driver,
	recorder record.EventRecorder,
	stop &lt;-chan struct{}) error
</code></pre>
<ol>
<li>Calls <code>getAvailableResources</code> using the <code>controlCoreClientBuilder</code> that returns a <code>map[schema.GroupVersionResource]bool</code> assigned to <code>availableresources</code>
<ul>
<li><code>getAvailableResources</code> waits till the api server is running by checking its <code>/healthz</code> using <code>wait.PollImmediate</code>. keeps re-creating the client using <code>clientbuilder.Client</code> method. </li>
<li>then uses <code>client.Discovery().ServerResources</code> which returns returns the supported resources for all groups and versions as a slice of <a href="https://github.com/kubernetes/apimachinery/blob/373a5f752d44989b9829888460844849878e1b6e/pkg/apis/meta/v1/types.go#L1131">*metav1.APIResourceList</a> (which encapsulates a <a href="https://github.com/kubernetes/apimachinery/blob/v0.26.1/pkg/apis/meta/v1/types.go#L1081">[]APIResource</a>) and then converts that to a <code>map[schema.GroupVersionResource]bool</code> `</li>
</ul>
</li>
<li>Creates a <code>controlMachineClient</code> using <code>controlMachineClientBuilder.ClientOrDie(&quot;machine-controller&quot;).MachineV1alpha1()</code> which is a client of type <a href="https://pkg.go.dev/github.com/gardener/machine-controller-manager@v0.48.0/pkg/client/clientset/versioned/typed/machine/v1alpha1#MachineV1alpha1Interface">MachineV1alpha1Interface</a>. This interface is a composition of <a href="https://pkg.go.dev/github.com/gardener/machine-controller-manager@v0.48.0/pkg/client/clientset/versioned/typed/machine/v1alpha1#MachinesGetter">MachineGetter</a>,<a href="https://pkg.go.dev/github.com/gardener/machine-controller-manager@v0.48.0/pkg/client/clientset/versioned/typed/machine/v1alpha1#MachineClassesGetter">MachineClassesGetter</a>, <a href="https://pkg.go.dev/github.com/gardener/machine-controller-manager@v0.48.0/pkg/client/clientset/versioned/typed/machine/v1alpha1#MachineDeploymentsGetter">MachineDeploymentsGetter</a> and <a href="https://pkg.go.dev/github.com/gardener/machine-controller-manager@v0.48.0/pkg/client/clientset/versioned/typed/machine/v1alpha1#MachineSetsGetter">MachineSetsGetter</a> allowing access to CRUD interface for machines, machine classes, machine deployments and machine sets. This client targets the control cluster - ie the cluster holding the machine crd's.</li>
<li>creates a <code>controlCoreClient</code> (of type: <a href="https://pkg.go.dev/k8s.io/client-go@v0.26.1/kubernetes#Clientset">kubernetes.Clientset</a> which is the standard k8s client-go client for accessing the k8s control cluster.</li>
<li>creates a <code>targetCoreClient</code> (of type: <a href="https://pkg.go.dev/k8s.io/client-go@v0.26.1/kubernetes#Clientset">kubernetes.Clientset</a>) which is the standard k8s client-go client for accessing the target cluster - in which machines will be spawned.</li>
<li>obtain the target cluster k8s version using the discovery interface and preserve it in <code>targetKubernetesVersion</code></li>
<li>if the <code>availableResources</code> does not contain the machine GVR,  exit <code>app.StartControllers</code> with error.</li>
<li>creates the following informer factories:</li>
</ol>
<ul>
<li><code>controlMachineInformerfactory</code> using the generated <a href="https://pkg.go.dev/github.com/gardener/machine-controller-manager@v0.48.0/pkg/client/informers/externalversions.NewFilteredSharedInformerFactory">pkg/client/informers/externalversions#NewFilteredSharedInformerFactory</a> passing the conrol machine client, the configured min resync period and control namespace.</li>
<li>Create <code>controlCoreInformerfactory</code> using the client-go core <a href="https://pkg.go.dev/k8s.io/client-go@v0.26.1/informers#NewFilteredSharedInformerFactory">informers#NewFilteredSharedInformerFactory</a> passing in the control core client, min resync period and control namespace.</li>
<li>Similarly create <code>targetCoreInformerFactory</code></li>
<li>Get the controller's <a href="https://pkg.go.dev/github.com/gardener/machine-controller-manager@v0.48.0/pkg/client/informers/externalversions/machine/v1alpha1#Interface">Machine Informers Facade</a> using <code>controlMachineInformerfactory.Machine().V1alpha1()</code> and assign to <code>machinesharedinformers</code></li>
</ul>
<ol start="8">
<li>Now create the <code>machinecontroller</code> using <a href="https://github.com/gardener/machine-controller-manager/blob/v0.48.0/pkg/util/provider/machinecontroller/controller.go#L77">machinecontroller.NewController</a> factory function, passing the below:
<ul>
<li>control namespace from <code>options.MCServer.Namespace</code></li>
<li><code>SafetyOptions</code> from <code>options.MCServer.SafetyOptions</code></li>
<li><code>NodeConditions</code> from <code>options.MCserver.NodeConditions</code>. (by default these would be : &quot;KernelDeadlock,ReadonlyFilesystem,DiskPressure,NetworkUnavailable&quot;)</li>
<li>clients: <code>controlMachineClient</code>, <code>controlCoreClient</code>, <code>targetCoreClient</code></li>
<li>the <code>driver</code> </li>
<li>Target Cluster Informers obtained from <code>targetCoreInformerfactory</code>:
<ul>
<li><a href="https://pkg.go.dev/k8s.io/client-go@v0.26.1/informers/core/v1#PersistentVolumeClaimInformer">PersistentVolumeClaimInformer</a></li>
<li><a href="https://pkg.go.dev/k8s.io/client-go@v0.26.1/informers/core/v1#PersistentVolumeInformer">PersistentVolumeInformer</a>, </li>
<li><a href="https://pkg.go.dev/k8s.io/client-go@v0.26.1/informers/storage/v1#VolumeAttachmentInformer">VolumeAttachmentsInformer</a> </li>
<li><a href="https://pkg.go.dev/k8s.io/client-go@v0.26.1/informers/policy/v1#PodDisruptionBudgetInformer">PodDisruptionBudgetInformer</a></li>
</ul>
</li>
<li>Control Cluster Informers obtained from <code>controlCoreInformerFactory</code> 
<ul>
<li><a href="https://pkg.go.dev/k8s.io/client-go@v0.26.1/informers/core/v1#SecretInformer">SecretInformer</a></li>
</ul>
</li>
<li><a href="https://pkg.go.dev/github.com/gardener/machine-controller-manager@v0.48.0/pkg/client/informers/externalversions/machine/v1alpha1#MachineClassInformer">MachineClassInformer</a>, <a href="https://pkg.go.dev/github.com/gardener/machine-controller-manager@v0.48.0/pkg/client/informers/externalversions/machine/v1alpha1#MachineInformer">MachineInformer</a> using <code>machinesharedinformers.MachineClasses()</code> and <code>machinesharedinformers.Machines()</code></li>
<li>The event recorder created earlier</li>
<li><code>targetKubernetesVersion</code></li>
</ul>
</li>
<li>Start <code>controlMachineInformerFactory</code>, <code>controlCoreInformerFactory</code> and <code>targetCoreInformerFactory</code> by calling <a href="https://pkg.go.dev/k8s.io/client-go@v0.26.1/informers#SharedInformerFactory">SharedInformerfactory.Start</a> passing the <code>stop</code> channel. </li>
<li>Launches the <a href="https://github.com/gardener/machine-controller-manager/blob/v0.48.0/pkg/util/provider/machinecontroller/controller.go#L302">machinecontroller.Run</a> in new go-routine passing the stop channel.</li>
<li>Block forever using a <code>select{}</code></li>
</ol>
<h3 id="machine-controller-initialization"><a class="header" href="#machine-controller-initialization">Machine Controller Initialization</a></h3>
<p>the machine controller is constructed using <a href="https://github.com/gardener/machine-controller-manager/blob/v0.48.0/pkg/util/provider/machinecontroller/controller.go#L77">controller.NewController</a>
factory function which initializes the <code>controller</code> struct.</p>
<h4 id="1-newcontroller-factory-func"><a class="header" href="#1-newcontroller-factory-func">1. NewController factory func</a></h4>
<p>mc is constructed using the factory function below:</p>
<pre><code class="language-go">func NewController(
	namespace string,
	controlMachineClient machineapi.MachineV1alpha1Interface,
	controlCoreClient kubernetes.Interface,
	targetCoreClient kubernetes.Interface,
	driver driver.Driver,
	pvcInformer coreinformers.PersistentVolumeClaimInformer,
	pvInformer coreinformers.PersistentVolumeInformer,
	secretInformer coreinformers.SecretInformer,
	nodeInformer coreinformers.NodeInformer,
	pdbV1beta1Informer policyv1beta1informers.PodDisruptionBudgetInformer,
	pdbV1Informer policyv1informers.PodDisruptionBudgetInformer,
	volumeAttachmentInformer storageinformers.VolumeAttachmentInformer,
	machineClassInformer machineinformers.MachineClassInformer,
	machineInformer machineinformers.MachineInformer,
	recorder record.EventRecorder,
	safetyOptions options.SafetyOptions,
	nodeConditions string,
	bootstrapTokenAuthExtraGroups string,
	targetKubernetesVersion *semver.Version,
) (Controller, error) 

</code></pre>
<h4 id="11-init-controller-struct"><a class="header" href="#11-init-controller-struct">1.1 Init Controller Struct</a></h4>
<p>Create and Initialize the Controller struct initializing rate-limiting work queues for secrets: <code>controller.secretQueue</code>,  nodes: <code>controller.nodeQueue</code>, machines: <code>controller.machineQueue</code>, machineclass: <code>controller.machineClassQueue</code>. Along with 2 work queues used by safety controllers: <code>controller.machineSafetyOrphanVMsQueue</code> and <code>controller.machineSafetyAPIServerQueue</code></p>
<p>Example: </p>
<pre><code class="language-go">controller := &amp;controller {
	//...
 secretQueue:                   workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), &quot;secret&quot;),
 machineQueue=workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), &quot;machine&quot;),
	//...
}
</code></pre>
<h4 id="12-assign-listers-and-hassynced-funcs-to-controller-struct"><a class="header" href="#12-assign-listers-and-hassynced-funcs-to-controller-struct">1.2 Assign Listers and HasSynced funcs to controller struct</a></h4>
<pre><code class="language-go">	// initialize controller listers from the passed-in shared informers (8 listers)
	controller.pvcLister = pvcInformer
	controller.pvLister = pvinformer.Lister()
    controller.machineLister = machineinformer.lister()

	controller.pdbV1Lister = pdbV1Informer.Lister()
	controller.pdbV1Synced = pdbV1Informer.Informer().HasSynced

	// ...

	// assign the HasSynced function from the passed-in shared informers
	controller.pvcSynced = pvcInformer.Informer().HasSynced
	controller.pvSynced = pvInformer.Informer().HasSynced
    controller.machineSynced = machineInformer.Informer().HasSynced
</code></pre>
<h4 id="13-register-controller-event-handlers-on-informers"><a class="header" href="#13-register-controller-event-handlers-on-informers">1.3 Register Controller Event Handlers on Informers.</a></h4>
<p>An informer invokes registered event handler when a k8s object changes. </p>
<p>Event handlers are registered using <code>&lt;ResourceType&gt;Informer().AddEventhandler</code> function. </p>
<p>The controller initialization registers add//delete event handlers for secrets. add/update/delete event handlers for MachineClass, Machine and Node informers.</p>
<p>The event handlers generally add the object keys to the appropriate work queues which are later picked up and reconciled in processing in <code>controller.Run</code>.</p>
<p>The work queue is used to separate the delivery of the object from its processing. resource event handler functions extract the key of the delivered object and add it to the relevant work queue for future processing. (in <code>controller.Run</code>) </p>
<p>Example</p>
<pre><code class="language-go">secretInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{
	AddFunc:    controller.secretAdd,
	DeleteFunc: controller.secretDelete,
})
</code></pre>
<h5 id="131-secret-informer-callback"><a class="header" href="#131-secret-informer-callback">1.3.1 Secret Informer Callback</a></h5>
<pre class="mermaid">%%{init: {'themeVariables': { 'fontSize': '10px'}, &quot;flowchart&quot;: {&quot;useMaxWidth&quot;: false }}}%%

flowchart TB

SecretInformerAddCallback
--&gt;SecretAdd[&quot;controller.secretAdd(obj)&quot;]
--&gt;GetSecretKey[&quot;key, err := cache.DeletionHandlingMetaNamespaceKeyFunc(obj)&quot;]
--&gt;AddSecretQ[&quot;if err != nil c.secretQueue.Add(key)&quot;]

SecretInformeDeleteCallback
--&gt;SecretAdd
</pre>
<p>We must check for the <a href="https://pkg.go.dev/k8s.io/client-go/tools/cache#DeletedFinalStateUnknown">DeletedFinalStateUnknown</a> state of that secret in the cache before enqueuing its key. The <code>DeletedFinalStateUnknown</code> state means that the object has been deleted but that the watch deletion event was missed while disconnected from apiserver and the controller didn't react accordingly. Hence if there is no error, we can add the key to the queue.</p>
<h5 id="132-machine-class-informer-callbacks"><a class="header" href="#132-machine-class-informer-callbacks">1.3.2 Machine Class Informer Callbacks</a></h5>
<h6 id="machineclass-adddelete-callback-1"><a class="header" href="#machineclass-adddelete-callback-1">MachineClass Add/Delete Callback 1</a></h6>
<pre class="mermaid">%%{init: {'themeVariables': { 'fontSize': '10px'}, &quot;flowchart&quot;: {&quot;useMaxWidth&quot;: false }}}%%

flowchart TB
MachineClassInformerAddCallback1
--&gt;
MachineAdd[&quot;controller.machineClassToSecretAdd(obj)&quot;]
--&gt;CastMC[&quot;
	mc, ok := obj.(*v1alpha1.MachineClass)
&quot;]
--&gt;EnqueueSecret[&quot;
	c.secretQueue.Add(mc.SecretRef.Namespace + '/' + 
	mc.SecretRef.Name)
	c.secretQueue.Add(mc.CredentialSecretRef.Namespace + '/' + mc.CredentialSecretRef.Namespace.Name)
&quot;]

MachineClassToSecretDeleteCallback1
--&gt;MachineAdd
</pre>
<h6 id="machineclass-update-callback-1"><a class="header" href="#machineclass-update-callback-1">MachineClass Update Callback 1</a></h6>
<pre class="mermaid">%%{init: {'themeVariables': { 'fontSize': '10px'}, &quot;flowchart&quot;: {&quot;useMaxWidth&quot;: false }}}%%

flowchart TB
MachineClassInformerUpdateCallback1
--&gt;
MachineAdd[&quot;controller.machineClassToSecretUpdate(oldObj, newObj)&quot;]
--&gt;CastMC[&quot;
	old, ok := oldObj.(*v1alpha1.MachineClass)
	new, ok := newObj.(*v1alpha1.MachineClass)
&quot;]
--&gt;RefNotEqual{&quot;old.SecretRef != 
	new.SecretRef?&quot;}
--Yes--&gt;EnqueueSecret[&quot;
	c.secretQueue.Add(old.SecretRef.Namespace + '/' + old.SecretRef.Name)
	c.secretQueue.Add(new.SecretRef.Namespace + '/' + new.SecretRef.Name)
&quot;]
--&gt;CredRefNotEqual{&quot;old.CredentialsSecretRef!=
new.CredentialsSecretRef?&quot;}
--Yes--&gt;EnqueueCredSecretRef[&quot;
c.secretQueue.Add(old.CredentialsSecretRef.Namespace + '/' + old.CredentialsSecretRef.Name)
c.secretQueue.Add(new.CredentialsSecretRef.Namespace + '/' + new.CredentialsSecretRef.Name)
&quot;]
</pre>
<h6 id="machineclass-adddeleteupdate-callback-2"><a class="header" href="#machineclass-adddeleteupdate-callback-2">MachineClass Add/Delete/Update Callback 2</a></h6>
<pre class="mermaid">%%{init: {'themeVariables': { 'fontSize': '10px'}, &quot;flowchart&quot;: {&quot;useMaxWidth&quot;: false }}}%%

flowchart TB
MachineClassInformerAddCallback2
--&gt;
MachineAdd[&quot;controller.machineClassAdd(obj)&quot;]
--&gt;CastMC[&quot;
	key, err := cache.DeletionHandlingMetaNamespaceKeyFunc(obj)
	if err != nil c.machineClassQueue.Add(key)
&quot;]
MachineClassInformerDeleteCallback2
--&gt;MachineAdd

MachineClassInformeUpdateCallback2
--&gt;MachineUpdate[&quot;controller.machineClassUpdate(oldObj,obj)&quot;]
--&gt;MachineAdd
</pre>
<h5 id="132-machine-informer-callbacks"><a class="header" href="#132-machine-informer-callbacks">1.3.2 Machine Informer Callbacks</a></h5>
<h6 id="machine-addupdatedelete-callbacks-1"><a class="header" href="#machine-addupdatedelete-callbacks-1">Machine Add/Update/Delete Callbacks 1</a></h6>
<pre class="mermaid">%%{init: {'themeVariables': { 'fontSize': '10px'}, &quot;flowchart&quot;: {&quot;useMaxWidth&quot;: false }}}%%

flowchart TB
MachineAddCallback1
--&gt;AddMachine[&quot;controller.addMachine(obj)&quot;]
--&gt;EnqueueMachine[&quot;
	key, err := cache.MetaNamespaceKeyFunc(obj)
	//Q: why don't we use DeletionHandlingMetaNamespaceKeyFunc here ?
	if err!=nil c.machineQueue.Add(key)
&quot;]
MachineUpdateCallback1--&gt;AddMachine
MachineDeleteCallback1--&gt;AddMachine
</pre>
<h6 id="machine-updatedelete-callbacks-2"><a class="header" href="#machine-updatedelete-callbacks-2">Machine Update/Delete Callbacks 2</a></h6>
<p>DISCUSS THIS.</p>
<pre class="mermaid">%%{init: {'themeVariables': { 'fontSize': '10px'}, &quot;flowchart&quot;: {&quot;useMaxWidth&quot;: false }}}%%

flowchart TB
MachineUpdateCallback2
--&gt;UpdateMachineToSafety[&quot;controller.updateMachineToSafety(oldObj, newObj)&quot;]
--&gt;EnqueueSafetyQ[&quot;
	newM := newObj.(*v1alpha1.Machine)
	if multipleVMsBackingMachineFound(newM) {
		c.machineSafetyOrphanVMsQueue.Add('')
	}
&quot;]
MachineDeleteCallback2
--&gt;DeleteMachineToSafety[&quot;deleteMachineToSafety(obj)&quot;]
--&gt;EnqueueSafetyQ1[&quot;
	c.machineSafetyOrphanVMsQueue.Add('')
&quot;]
</pre>
<h5 id="133-node-informer-callbacks"><a class="header" href="#133-node-informer-callbacks">1.3.3 Node Informer Callbacks</a></h5>
<h6 id="node-add-callback"><a class="header" href="#node-add-callback">Node Add Callback</a></h6>
<pre class="mermaid">%%{init: {'themeVariables': { 'fontSize': '10px'}, &quot;flowchart&quot;: {&quot;useMaxWidth&quot;: false }}}%%

flowchart TB
NodeaAddCallback
--&gt;InvokeAddNodeToMachine[&quot;controller.addNodeToMachine(obj)&quot;]
--&gt;AddNodeToMachine[&quot;
	node := obj.(*corev1.Node)
	if node.ObjectMeta.Annotations has NotManagedByMCM return;
	key, err := cache.DeletionHandlingMetaNamespaceKeyFunc(obj)
	if err != nil return
&quot;]
--&gt;GetMachineFromNode[&quot;
	machine := (use machineLister to get first machine whose 'node' label equals key)
&quot;]
--&gt;ChkMachine{&quot;
machine.Status.CurrentStatus.Phase != 'CrashLoopBackOff'
&amp;&amp;
nodeConditionsHaveChanged(
  machine.Status.Conditions, 
  node.Status.Conditions) ?
&quot;}
--Yes--&gt;EnqueueMachine[&quot;
	mKey, err := cache.MetaNamespaceKeyFunc(obj)
	if err != nil return
	controller.machineQueue.Add(mKey)
&quot;]

</pre>
<h6 id="node-delete-callback"><a class="header" href="#node-delete-callback">Node Delete Callback</a></h6>
<p>This is straightforward - it checks that the node has an associated machine and if so, enqueues the machine on the <code>machineQueue</code></p>
<pre class="mermaid">%%{init: {'themeVariables': { 'fontSize': '10px'}, &quot;flowchart&quot;: {&quot;useMaxWidth&quot;: false }}}%%

flowchart TB
NodeDeleteCallback
--&gt;InvokeDeleteNodeToMachine[&quot;controller.deleteNodeToMachine(obj)&quot;]
--&gt;DeleteNodeToMachine[&quot;
	key, err := cache.DeletionHandlingMetaNamespaceKeyFunc(obj)
	if err != nil return
&quot;]
--&gt;GetMachineFromNode[&quot;
	machine := (use machineLister to get first machine whose 'node' label equals key)
	if err != nil return
&quot;]
--&gt;EnqueueMachine[&quot;
	mKey, err := cache.MetaNamespaceKeyFunc(obj)
	if err != nil return
	controller.machineQueue.Add(mKey)
&quot;]
</pre>
<h6 id="node-update-callback"><a class="header" href="#node-update-callback">Node Update Callback</a></h6>
<p><code>controller.updateNodeTomachine</code> is specified as <code>UpdateFunc</code> registered for the <code>nodeInformer</code>. </p>
<p>In a nutshell, it simply delegates to <code>AddNodeTomachine(newobj)</code> described earlier, <em>except</em> if the node has the annotation <code>machineutils.TriggerDeletionByMCM</code> (value: <code>node.machine.sapcloud.io/trigger-deletion-by-mcm</code>).  In this case it gets the <code>machine</code> obj corresponding to the node and then leverages <code>controller.controlMachineClient</code> to delete the machine object.</p>
<p>NOTE:  This annotation was introduced for the user to add on the node. This gives them an indirect way to delete the machine object because they donâ€™t have access to control plane.</p>
<p>Snippet shown below with error handling+logging omitted.</p>
<pre><code class="language-go">func (c *controller) updateNodeToMachine(oldobj, newobj interface{}) {
	node := newobj.(*corev1.node)
	// check for the triggerdeletionbymcm annotation on the node object
	// if it is present then mark the machine object for deletion
	if value, ok := node.annotations[machineutils.TriggerDeletionByMCM]; ok &amp;&amp; value == &quot;true&quot; {
		machine, err := c.getMachineFromnOde(node.name)
		if machine.deletiontimestamp == nil {
			c.controlmachineclient
			.Machines(c.namespace)
			.Delete(context.Background(), machine.Name, metav1.Deleteoptions{});		
		} 
	}  else {
		c.addnodeToMachine(newobj)
	}
}
</code></pre>
<h3 id="machine-controller-run"><a class="header" href="#machine-controller-run">Machine Controller Run</a></h3>
<pre><code class="language-go">func (c *controller) Run(workers int, stopch &lt;-chan struct{}) {
	// ...
}

</code></pre>
<h4 id="1-wait-for-informer-caches-to-sync"><a class="header" href="#1-wait-for-informer-caches-to-sync">1. Wait for Informer Caches to Sync</a></h4>
<p>When an informer starts, it will build a cache of all resources it currently watches which is lost when the application
restarts. This means that on startup, each of your handler functions will be invoked as the initial state is built. If this
is not desirable, one should wait until the caches are synced before performing any updates. This can be done using the
<a href="https://pkg.go.dev/k8s.io/client-go/tools/cache#WaitForCacheSync">cache.WaitForCacheSync</a> function.</p>
<pre><code class="language-go">if !cache.WaitForCacheSync(stopCh, c.secretSynced, c.pvcSynced, c.pvSynced, c.volumeAttachementSynced, c.nodeSynced, c.machineClassSynced, c.machineSynced) {
	runtimeutil.HandleError(fmt.Errorf(&quot;Timed out waiting for caches to sync&quot;))
	return
}

</code></pre>
<h4 id="2-register-on-prometheus"><a class="header" href="#2-register-on-prometheus">2. Register On Prometheus</a></h4>
<p>The Machine controller struct implements the <a href="https://pkg.go.dev/github.com/prometheus/client_golang@v1.13.0/prometheus#Collector">prometheus.Collector</a> interface and can therefore
be then be registered on prometheus metrics registry. </p>
<pre><code class="language-go">prometheus.MustRegister(controller)
</code></pre>
<p>Collectors which are added to the registry will collect metrics to expose them via the metrics endpoint of the MCM every time when the endpoint is called.</p>
<h5 id="21-describe-metrics-controllerdescribe"><a class="header" href="#21-describe-metrics-controllerdescribe">2.1 Describe Metrics (controller.Describe)</a></h5>
<p>All <a href="https://pkg.go.dev/github.com/prometheus/client_golang@v1.13.0/prometheus#Metric">promethueus.Metric</a> that are collected must first be described using a <a href="https://pkg.go.dev/github.com/prometheus/client_golang@v1.13.0/prometheus#Desc">prometheus.Desc</a> which is the immutable  <em>meta-data</em> about a metric.</p>
<p>As can be seen below the machine controller sends a description of <a href="https://pkg.go.dev/github.com/gardener/machine-controller-manager@v0.48.0/pkg/util/provider/metrics#pkg-variables">metrics.MachineCountDesc</a> to prometheus. this is <code>mcm_machine_items_total</code> which is the count of machines managed by controller. </p>
<p>This <code>Describe</code> callback is called by <code>prometheus.MustRegister</code></p>
<p>Doubt: we currently appear to have  only have one metric for the mc ?</p>
<pre><code class="language-go">var	MachineCountDesc = prometheus.NewDesc(&quot;mcm_machine_items_total&quot;, &quot;Count of machines currently managed by the mcm.&quot;, nil, nil)

func (c *controller) Describe(ch chan&lt;- *prometheus.desc) {
	ch &lt;- metrics.MachineCountDesc
}
</code></pre>
<p>A <a href="https://pkg.go.dev/github.com/prometheus/client_golang/prometheus#Gauge">prometheus.Gauge</a> is a Metric that represents a single numerical value that can arbitrarily go up and down. We use a Gauge for the machine count.</p>
<h5 id="21-collect-metrics-controllercollect"><a class="header" href="#21-collect-metrics-controllercollect">2.1 Collect Metrics (controller.Collect)</a></h5>
<p><code>Collect</code> is called by the prometheus registry when collecting
metrics. The implementation sends each collected metric via the
provided channel and returns once the last metric has been sent. the
descriptor of each sent metric is one of those returned by <code>Describe</code></p>
<pre><code class="language-go">// Collect is method required to implement the prometheus.Collect interface.
func (c *controller) Collect(ch chan&lt;- prometheus.Metric) {
	c.CollectMachineMetrics(ch)
	c.CollectMachineControllerFrozenStatus(ch)
}
</code></pre>
<h6 id="211-collect-machine-metrics"><a class="header" href="#211-collect-machine-metrics">2.1.1 Collect Machine Metrics</a></h6>
<pre><code class="language-go">func (c *controller) CollectMachineMetrics(ch chan&lt;- prometheus.Metric) 
</code></pre>
<p>A machine managed by MCM is described on Prometheus using a <a href="https://pkg.go.dev/github.com/prometheus/client_golang/prometheus#GaugeVec">prometheus.GaugeVec</a> constructed using the factory function <a href="https://pkg.go.dev/github.com/prometheus/client_golang/prometheus#NewGaugeVec">prometheus.NewGaugeVec</a>.</p>
<p>Example:</p>
<pre><code class="language-go">var MachineInfo prometheus.GaugeVec = prometheus.NewGaugeVec(prometheus.GaugeOpts{
		Namespace: namespace,
		Subsystem: machineSubsystem,
		Name:      &quot;info&quot;,
		Help:      &quot;Information of the Machines currently managed by the mcm.&quot;,
	}, []string{&quot;name&quot;, &quot;namespace&quot;, &quot;createdAt&quot;,
		&quot;spec_provider_id&quot;, &quot;spec_class_api_group&quot;, &quot;spec_class_kind&quot;, &quot;spec_class_name&quot;})
</code></pre>
<p>One invokes the <a href="https://pkg.go.dev/github.com/prometheus/client_golang/prometheus#GaugeVec.With">GaugeVec.With</a> method passing a <a href="https://pkg.go.dev/github.com/prometheus/client_golang/prometheus#Labels">prometheus.Labels</a> which is a <code>map[string]string</code> to obtain a <a href="https://pkg.go.dev/github.com/prometheus/client_golang/prometheus#Gauge">prometheus.Gauge</a></p>
<ol>
<li>Gets the list of machines using the <code>machineLister</code></li>
<li></li>
</ol>
<h4 id="3-create-controller-worker-go-routines-applying-reconciliations"><a class="header" href="#3-create-controller-worker-go-routines-applying-reconciliations">3. create controller worker go-routines applying reconciliations</a></h4>
<pre><code class="language-go">func (c *controller) run(workers int, stopch &lt;-chan struct{}) {
	//.. 3
	waitgroup sync.waitgroup
	for i := 0; i &lt; workers; i++ {
		createworker(c.secretqueue, &quot;clustersecret&quot;, maxretries, true, c.reconcileclustersecretkey, stopch, &amp;waitgroup)
		createworker(c.machineclassqueue, &quot;clustermachineclass&quot;, maxretries, true, c.reconcileclustermachineclasskey, stopch, &amp;waitgroup)
		createworker(c.nodequeue, &quot;clusternode&quot;, maxretries, true, c.reconcileclusternodekey, stopch, &amp;waitgroup)
		createworker(c.machinequeue, &quot;clustermachine&quot;, maxretries, true, c.reconcileclustermachinekey, stopch, &amp;waitgroup
		createworker(c.machinesafetyorphanvmsqueue, &quot;clustermachinesafetyorphanvms&quot;, maxretries, true, c.reconcileclustermachinesafetyorphanvms, stopch, &amp;waitgroup)
		createworker(c.machinesafetyapiserverqueue, &quot;clustermachineapiserver&quot;, maxretries, true, c.reconcileclustermachinesafetyapiserver, stopch, &amp;waitgroup)
	}
	&lt;-stopch
	waitgroup.wait()
}

</code></pre>
<h5 id="31-createworker"><a class="header" href="#31-createworker">3.1 createworker</a></h5>
<p><code>createworker</code> creates and runs a go-routine that just processes items in the
specified <code>queue</code>. the worker will run until <code>stopch</code> is closed. the worker will be
added to the wait group when started and marked done when finished.</p>
<pre><code class="language-go">func createworker(queue workqueue.ratelimitinginterface, resourcetype string, maxretries int, forgetaftersuccess bool, reconciler func(key string) error, stopch &lt;-chan struct{}, waitgroup *sync.waitgroup) {
	waitgroup.add(1)
	go func() {
		wait.until(worker(queue, resourcetype, maxretries, forgetaftersuccess, reconciler), time.second, stopch)
		waitgroup.done()
	}()
}
</code></pre>
<p><a href="https://github.com/gardener/machine-controller-manager/blob/v0.47.0/pkg/util/provider/machinecontroller/controller.go#l369">worker</a> returns a function that </p>
<ol>
<li>de-queues items (keys) from the work <code>queue</code>. the <code>key</code>s that are obtained using work <code>queue.get</code> to be strings of the form <code>namespace/name</code> of the resource. </li>
<li>processes them by invoking the <code>reconciler(key)</code> function 
<ol>
<li>the purpose of the <code>reconciler</code> is to compares the actual state with the desired state, and attempts to converge the two. it should then update the <code>status</code> block of the resource.</li>
<li>if <code>reconciler</code> returns an error, requeue the item up to <code>maxretries</code> before giving up.</li>
</ol>
</li>
<li>marks items as done.</li>
</ol>
<p>then we execute the <code>reconciler</code>. </p>
<pre><code class="language-go">func worker(queue workqueue.ratelimitinginterface, resourcetype string, maxretries int, forgetaftersuccess bool, reconciler func(key string) error) func() {
	return func() {
		exit := false
		for !exit {
			exit = func() bool {
				key, quit := queue.get()
				if quit {
					return true
				}
				defer queue.done(key)

				err := reconciler(key.(string))
				if err == nil {
					if forgetaftersuccess { // always true for mc
						queue.forget(key)
					}
					return false
				}

				if queue.numrequeues(key) &lt; maxretries {
					queue.addratelimited(key)
					return false
				}

				queue.forget(key)
				return false
			}()
		}
	}
}
</code></pre>
<h4 id="4-reconciliation-functions-executed-by-worker"><a class="header" href="#4-reconciliation-functions-executed-by-worker">4. reconciliation functions executed by worker</a></h4>
<p>the controller starts worker go-routines that pop out keys from the relevant workqueue and execute the reconcile function.</p>
<p>See reconcile chapters.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../mcm_facilities.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../machine-controller/reconcile-cluster-machine-class.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../mcm_facilities.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../machine-controller/reconcile-cluster-machine-class.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>


    </body>
</html>
